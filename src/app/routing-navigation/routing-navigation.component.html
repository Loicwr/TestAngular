<h1>Angular Routing & Navigation - Cheatsheet (v20)</h1>
<p>C'est un module Angular dédié à la configuration du système de routes. Il déclare quelles URL affichent quels composants, 
    et permet à Angular de gérer la navigation entre les pages sans recharger toute l'application (Single Page Application).</p>

<h2>1. Créer et configurer app-routing.module.ts</h2>
<p>Crée le module avec CLI<br>
    ng generate module app-routing --flat --module=app
</p>

<ul>
    <li> --flat : place le fichier à la racine.</li>
    <li> --module=app : l'importe automatiquement dans Appmodule.</li>
</ul>

<h4>Dans app-routing.module.ts, on importe les éléments nécessaires :</h4>

<ul>
    <li>import NgModule from '(arobase)angular/core'</li>
    <li>import RouterModule, Routes from '(arobase)angular/router'</li>
</ul>

<h4>Déclare un tableau de routes :</h4>
<ul>
    <li><code> const routes: Routes = [</code></li>
    <li><code>{{ '{' }} path: 'home', component: HomeComponent {{ '}' }}</code></li>
    <li><code>{{ '{' }} path: '', redirectTo: '/home', pathMatch: 'full' {{ '}' }}</code></li>
    <li><code>{{ '{' }} path: '**', component: NotFoundComponent {{ '}' }}</code></li>
    <li><code>{{ ']' }};</code></li>
</ul>

<p>Chaque objet du tableau routes contient :</p>
<ul>
    <li>path : le chemin de l'URL (ex:/home)</li>
    <li>component: le composant à afficher</li>
    <li>redirectTo: redirige l'utilisateur vers une autre route</li>
    <li>pathMatch: 'full': exige une correspondance exacte du chemin</li>
    <li>**: wildcard ( route catch-all pour le erreurs 404 )</li>
</ul>

<h4>Configure RouterModule :</h4>
<ul>
    <li><code>&#64;NgModule ({{ '{' }})</code></li>
    <li><code>imports: [RouterModule.forRoot(routes)]</code></li>
    <li><code>exports: [RouterModule]</code></li>
    <li><code>&#123; &#125;&#41;</code></li>
    <li><code>export class AppRoutingModule {{ '{' }}{{ '}' }}</code></li>
</ul>

<h2>2. Définir les routes de base</h2>
<p>Associe des url spécifique à des composants.</p>

<p>Exemple courant :</p>
<ul>
    <li><code>const routes: Routes = [</code></li>
    <li><code>{{ '{' }} path: 'dashboard', component: DashboardComponent {{ '}' }},</code> //route simple</li>
    <li><code>{{ '{' }} path: '', redirectTo: '/dashboard', pathMatch: 'full' {{ '}' }},</code> // route par défaut</li>
    <li><code>{{ '{' }} path: '**', component: NotFoundComponent {{ '}' }}</code> //route de fallback</li>
    <li><code>];</code></li>
</ul>

<p>À retenir :</p>
<ul>
    <li>path: '' :redirige l'accès à la racine du site.</li>
    <li>pathMatch: 'full' : signife que l'URL doit être strictement vide ('')</li>
    <li>** : capture toutes les URL non prévues(404)</li>
</ul>

<h2>3. Ajouter <code>&lt;router-outlet&gt;</code> dans app.component.html</h2>
<p>C'est ici que s'affiche dynamiquelent les composabts liés aux routes.</p>

<p>Code :</p>
<ul>
    <li><code>dans app.component.html</code></li>
    <li><code>&lt;app-navbar&gt;&lt;/app-navbar&gt;</code></li>
    <li><code>&lt;router-outlet&gt;&lt;/router-outlet&gt;</code></li>
    <li><code>&lt;app-footer&gt;&lt;/app-footer&gt;</code></li>
</ul>

<h4>explication :</h4>
<ul>
    <li><code>Le &lt;router-outlet&gt; agit comme un point d'injection.</code></li>
    <li>Angular y charge automatiquement le composant correspondant à la active</li>
    <li>Tu peux aussi en avoir plusieurs pour les routes enfants(routing imbriqué)</li>
</ul>

<h2>4. Naviguer avec [routerlink]</h2>
<p>Crée des liens vers des routes sans recharger la page.</p>

<p>Exemples :</p>
<ul>
    <li>Lien statiques :</li>
    <li><code>&lt;a [routerLink]="['/dashboard']"&gt;dashboard&lt;/a&gt;</code></li>
    <li>Liens dynamiques avec paramètres :</li>
    <li><code>&lt;a [routerLink]="['/produit', 42]"&gt;Voir produit 42&lt;/a&gt;</code></li>
</ul>

<p>Bonnes pratiques :</p>
<ul>
    <li>Toujours utiliser [routerLink] plutôt que href pour la navigation interne.</li>
    <li>[routerLinkActive]="['active']" peut ajouter une classe CSS active :</li>
    <li><code>&lt;a [routerLink]="['/dashboard']"&gt;dashboard&lt;/a&gt;</code></li>
</ul>

<h2>5. Ajouter une route avec paramètre :id</h2>
<p>Permet d'avoir des routes dynamiques( ex:/produit/42 )</p>

<p>Déclaration dans app-routing.module.ts :</p>
<ul>
    <li><code>const routes: Routes = [</code></li>
    <li><code>{{ '{' }} path: 'produit/:id', component: ProduitDetailComponent {{ '}' }}</code></li>
    <li><code>{{ ']' }};</code></li>
</ul>

<p>À noter :</p>
<ul>
    <li><code>:id</code> : est un paramètre de route.</li>
    <li>Tu peux en définir plusieurs exemple :</li>
    <li><code>{{ '{' }} path: 'user/:userId/post/:postId', component: PostComponent {{ '}' }}</code></li>
</ul>

<h2>6. Récupérer un paramètre avec ActivateRoute</h2>
<p>Utilie pour récupérer un id ou autre dans le composant concerné.</p>

<p>1. Injecte le service ActivateRoute dans le constructeur :</p>
<ul>
    <li><code>import {{ '{' }} ActivatedRoute {{ '}' }} from '&#64;angular/router'</code></li>
    <li><code>constructor(private route: ActivatedRoute){{ '{' }}{{ '}' }}</code></li>
</ul>

<p>2. Récupère le paramètre</p>
<ul>
    <li><code>ngOnInit() {{ '{' }}</code></li>
    <li><code>const id = this.route.snapshot.paramMap.get('id');</code></li>
    <li><code>console.log('ID produit:', id);</code></li>
    <li><code>{{ '}' }}</code></li>
</ul>

<p>3. Pour écouter les changements ( ex: route changeante ) :</p>
<ul>
    <li><code>ngOnInit() {{ '{' }}</code></li>
    <li><code>this.route.paramMap.subscribe( params =&gt; {{ '{' }} </code></li>
    <li><code>const id = params.get('id');</code></li>
    <li><code>console.log('ID mis à jour:', id);</code></li>
    <li><code>{{ '}' }});</code></li>
    <li><code>{{ '}' }}</code></li>
</ul>